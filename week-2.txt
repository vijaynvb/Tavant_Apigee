1. microservices
2. http
3. rest 
4. OAS -> Swagger -> 
    documenting rest api's 
    API -> interface
        1. Design first -> 
            1. service developer -> buid rest api 
            2. front end application dev -> frontend app
        2. code first approach -> 
            1. service developer -> generate the swagger document 
    OAS -> upload in apigee -> crete proxy with conditional flows

end developer[angular] -> proxy[34.107.140.123.nip.io/swagger-petstore1/pet/findByStatus?status=sold] -> target end point [https://petstore.swagger.io/v2/pet/findByStatus?status=sold]
                         1. enable security
                         2. content negotiation
                         3. cors 
                         4. tsl 
                         5. api managements -> [subscriptions-> quota 1s -> 3 request, spike arest]
                         6. url rewrites
                            1. headers -> query params 
                            2. oauth [encryption] -> basicauth [encoding]
                            3. rest -> soap conversion 

postman -> pagecount -> headers 
proxy -> headers -> queryparmas 
    1. AssignMessage -> request [url, headers, method, httpvesion, body] -> 
                        create new request object 
                        modify the request object -> 
backend -> displaying the request in its body


Todays Topics:

Trafic Management:
    1. Quota Policy
        1. Rate Limit: 
            1. 1 minute -> 5 request
            2. application specific rate liniting: [mobile, webapp]
            3. weightage configuration -> 
                1. verb -> get -> weightage 1        -> js policy for setting the weightage -> messageWeight
                           post -> weightage 2 
                2. allow only 4 request in a minute 
    2. Spike Arrest

eval gcp
request -> lb -> node 1 -> | count = 3
                 node 2 -> | 



Distributed = ture 
Synchronous = true

mobile ->       | decide on the app and alow access
webapp ->       |   3 req in a min for ever app


Recap: 
    1. Proxy -> 
        APPlication [HTTP req] -> [HTTP req] [lb] Proxy [nodes] -> [HTTP req] Backend service target service
    2. Flow req -> res [Context req res] -> Flow variables
        1. pre  
        2. conditional
        3. post 
    3. Policies
        1. XML to JSON -> res.body 
        2. json to xml -> res.body 
        3. Quota -> rate limiting
        4. Assign Message -> to manage flow variable and data 
        5. Extract variables -> context -> flow variables
        6. JS Policy -> 
            alter the counter -> get -> 1, post -> 2

1. calendar after 9am -> 
2. Rollingwindow type-> 
    6pm -> 6pm -3- 5pm -> 4-> failure
        -> 6.15pm -> 2 ->5.15pm-> 3 allow
3. flixi ->
    6.20.30 sec pm ->3-> to 6.21.30 sec 
    6.25.00 sec -> 3 -> 6.26.00 sec 

4. conditional rate limit -> 
    partner -> 10 per minute 
    public -> 1 per minute

5. proxy -> provide status of quota usage 
    1. available.count, consumed.count 

6. Fault error management: 
    1. if any policy is encountering some condition and the flow is short circuted -> fault will be raised
        flow -> falut rules -> mange the fault and customize the fault messages 

7. spike arrest policy -> 30 request per minute -> 
    for every 2 seconds it will allow one request.
    should be the first policy in perflow


Mediation Policies:

1. XML to JSON 
2. JSON to XML
3. Assign Message
4. Extract Variable
5. XSLT
6. SOAP Message Validation


client -> get request -> proxy -> post request backend
       -> employee -> age -> 18 -> proxy -> raise a fault

       post -> proxy -> post
                    -> get -> ServiceCallout

12-AM-NewRequest
proxy endpoint:
    post ->  /am-newrequest?id=1

two backends 
    1. https://httpbin-777149785799.us-east1.run.app/post
    2. https://https://jsonplaceholder.typicode.com/users

Assign Message -> context [request, response 9], flow variables [request, response]

13-Extract XML Payload data and validate

    <?xml version="1.0" encoding="UTF-8"?>
    <visitor>
        <name>Vijay</name>
        <age>18</age>
    </visitor>


14 - XML to HTML conversion using XSLT

    xml -> elements to deifne data              -> object 
    xsd -> schema definition for xml            -> class 
    xslt -> design of your data use the xslt    -> ui

6. SOAP Message Validation
7. AccessControlPolicy
8. BasicAuth 
9. JSONThreat
10. KVM -> 
11. APIVerifyKey -> [who, how, how]
12. API Product, Developers, APP -> secrect keys

SOAP -> Post 
    1. wsdl 
    2. SOAP Message 

Client -> SOAP Message [XML - Metadata(datatype of name, get,), data(name,age,addres)] -> Server
client [object->xml] -> soap message xml                                               -> server [xml->object]

client rest [json] ->  proxy [json -> xml [validation]]     -> SOAP server xml 

Access Control Policy:

    CIDR -> 10.10.2.4

*. BasicAuth -> 
    login -> user name and password -> encoded with basic auth -> decode key -> username and password 

    Encode -> algorithum to secure data 
    Decode -> reverse algorithum it will decode the data 

    encryption -> algorithum + key to secure the data 
    Decryption -> algorithum + ? to decrypt

JSON Threat Protection:

    {
    "hello1": "world1",
    "hello2": "world2",
    "hello3": "world3",
    "hello4": "world4",
    "hello5": "world5",
    "hello6": "world6",
    "hello7": "world7",
    "hello8": "world8",
    "hello9": "world9",
    "hello10": "world10",
    "hello11": "world11",
    "hello12": "world12",
    "hello13": "world13",
    "hello14": "world14",
    "hello15": "world15",
    "hello16": "world16",
    "hello17": "world17"
    }


KVM -> key value management -> 

    Target -> api key -> 